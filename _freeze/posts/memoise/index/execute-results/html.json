{
  "hash": "063dc8a3b0249c0f8505ee29a82a55fe",
  "result": {
    "markdown": "---\ntitle: \"Faste`R` functions with `memoise`\"\ndate: \"2022-12-27\"\ncategories: [R, memoise, Advanced R / R avanzado, programming tips / tips de programaci√≥n]\nimage: \"memoise.png\"\nlang: en\ndraft: false\nabstract: \"In this entry I discuss how to speed up recursive R functions with the memory-trick of `memoise`.\"\ncrossref:\n  eq-prefix: equation\nformat:\n  html:\n    fig-align: center\n    code-fold: false\n---\n\n\n## Hey, stop calling me!\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nMemoisation is a technique for speeding up functions via *memorization* of previously calculated results. To better explain the idea let's consider a recursive formulation of the Fibonacci sequence: \n\n$$\nf(n) = f(n- 1) + f(n-2)\n$$\n\nwith $f(1) = 1 = f(2)$. [^1]\n\n[^1]: Some definitions start with $f(0)$ but as `R` indexes vectors in $1$ we'd better start with $1$.\n\nAn implementation of the function is given by:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfibonacci <- function(n){\n  if(n <= 2){\n    return(1)\n  } else {\n    return(\n      fibonacci(n - 1) + fibonacci(n - 2)\n    )\n  }\n}\n```\n:::\n\n\nWe can calculate the time it takes to estimate the number up to `20`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(fibonacci(20))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: milliseconds\n          expr      min       lq    mean   median       uq      max neval\n fibonacci(20) 4.633172 5.810971 6.92568 6.418399 7.803796 17.74069   100\n```\n:::\n:::\n\nLarger values (like `fibonacci(100)`) start taking _a lot of time_. And that's because `fibonacci(100)` estimates the same values several times! To illustrate this point, consider `fibonacci(5)`. You can see that `fibonacci(3)` is estimated twice: once under `fibonacci(5)` itself and one under `fibonacci(4)`. This is extremely inefficient!\n\n\n```{mermaid}\ngraph TD\n    f5[fibonacci 5] --> f4[fibonacci 4]\n    f5[fibonacci 5] --> f3[fibonacci 3]\n    f3 --> f13[fibonacci 1]\n    f3 --> f23[fibonacci 2]\n    f4 --> f32[fibonacci 3]\n    f4 --> f2[fibonacci 2]\n    f32 --> f21[fibonacci 2]\n    f32 --> f11[fibonacci 1]\n```\n\n\nWe can calculate how many times the function `fibonacci` is called when estimating different numbers. In theory it should scale linearly _i.e._ `fibonacci(20)` should only calculate `fibonacci(1)`, `fibonacci(2)`, etc up to `fibonacci(19)` _once_. Hence the function should be called at most 20 times. However this isn't the case: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalls_f   <- 0\nfibonacci_calls <- function(n){\n  calls_f <<- calls_f + 1\n  if(n <= 2){\n    return(1)\n  } else {\n    return(\n      fibonacci_calls(n - 1) + fibonacci_calls(n - 2)\n    )\n  }\n}\ninvisible(fibonacci_calls(20))\n\ncat(paste(\"fibonacci_calls was called\",calls_f,\"times\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfibonacci_calls was called 13529 times\n```\n:::\n:::\n\n\nThe algorithm is extremely inefficient because it doesn't remember when estimating `fibonacci_calls(8)` that it already has estimated `fibonacci_calls(7)` during its estimation of `fibonacci_calls(9)`. Memoisation is a solution for this forgetfulness. \n\n## Hard coded memoisation  {#sec-hard-coded}\n\nAs we have seen, `fibonacci(20)` calls the `fibonacci` function  13,529 times. This inefficiency could be saved if the function could _memorize_ that it has already calculated the previous results. That is the utility of the memoisation trick. To save these memorizations (memoise!),  let's create a global vector where we'll keep the previous results of the `fibonacci` function. That is, the `j`-th entry of our vector will correspond to `fibonacci(j)`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Fibonacci cache vector up til fibonacci 1000 \n#fibonacci_cache[j] = fibonacci(j)\nfibonacci_cache <- rep(NA, 1000)\n\n#fibonacci_cache[1] = fibonacci(1) and fibonacci_cache[2] = fibonacci(2) \nfibonacci_cache[1:2] <- c(1, 1)\n\nmemoised_fibonacci <- function(n){\n  #Only calculate the values we haven't previously estimated\n  if (is.na(fibonacci_cache[n])){\n    fibonacci_cache[n] <<- memoised_fibonacci(n - 1) + memoised_fibonacci(n - 2)\n  } \n  return(fibonacci_cache[n])\n}\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLet's compare the speed of the previous function with this one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(fibonacci(20), memoised_fibonacci(20))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: nanoseconds\n                   expr     min        lq       mean    median      uq     max\n          fibonacci(20) 3942361 4796700.5 5059247.18 4838703.0 4977222 8489579\n memoised_fibonacci(20)     398     589.5    2730.04    1642.5    3855   28640\n neval\n   100\n   100\n```\n:::\n:::\n\n\nThis speed-up happens because the _new_ `memoised_fibonacci` only calculates the value `18` times! In contrast with the previous 13,529. For any custom function you build you can `memoise` this way _ooooor_ you can let the `memoise` package do it for you. \n\n## The `memoise` package\n\nThe `memoise` package does exactly what we did in the previous section by automatically memoising functions (with arguments that aren't necessarily numbers). It sets limits to the memory (our `fibonacci_cache`) as well as the amount of time a function _will remember_ previous results (time limit). To memoise a function you just need to call `memoise` over it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(memoise)\nmfibo <- function(n){\n  if(n <= 2){\n    return(1)\n  } else {\n    return(\n      mfibo(n - 1) + mfibo(n - 2) #It's important to call this with the memoized name\n    )\n  }\n}\nmfibo <- memoise(mfibo) #Memoization line\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nNote that this `memoisation` has additional overhead over the memoisation we did in @sec-hard-coded because `memoise` works even for non numeric arguments (which would have failed in our vectorized example). However the speed-up over the original is still there:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(fibonacci(20), mfibo(20), memoised_fibonacci(20)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: nanoseconds\n                   expr     min        lq       mean  median        uq      max\n          fibonacci(20) 5291457 6031574.5 7138627.87 6599172 7929635.0 14128101\n              mfibo(20)   58632   72422.5  151487.39  139772  190614.5   569502\n memoised_fibonacci(20)     606    1206.0    5186.56    3470    7506.5    39376\n neval\n   100\n   100\n   100\n```\n:::\n:::\n\n\nThe `memoise` package uses [cachem](https://cachem.r-lib.org/) which allows for fine control over where the previous results of the function. You can substitute the `#Memoization line` in the previous code for this memoise with finer control. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set memory to 100MB and time to memorizing only for 15 minutes\ncm    <- cachem::cache_mem(max_size = 100 * 1024^2, max_age = 15 * 60)\nmfibo <- memoise(mfibo, cache = cm)\n```\n:::\n\n\nTo keep previous computations across different R sessions you can cache directly to disk (slower) instead of memory:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncm    <- cachem::cache_disk(max_size = 100 * 1024^2, max_age = 15 * 60)\nmfibo <- memoise(mfibo, cache = cm)\n```\n:::\n\n\n## And in other languages?\n\nYou can also memoise in [the most recent versions of Python](https://docs.python.org/3/library/functools.html#functools.cache) either vie the built in `functools` or the [`memoization` project](https://github.com/lonelyenvoy/python-memoization). In [Julia you can Memoize.jl](https://github.com/JuliaCollections/Memoize.jl). Let me know if you are interested in an entry for any of these. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}