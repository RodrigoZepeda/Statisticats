{
  "hash": "de978903db95df4dc25e32a8d50a6cb2",
  "result": {
    "markdown": "---\ntitle: \"Regresiones (parte 1)\"\ndate: \"2022-11-06\"\ncategories: [regresiones / regression, regresión lineal / linear regression, R, español / Spanish, diagnóstico de modelos / model diagnosis]\nimage: \"quetelet.jpg\"\nlang: es\nabstract: \"En esta entrada discutimos los fundamentos de una regresión lineal (punto de vista probabilístico) así como su programación y diagnóstico en `R`\"\ncrossref:\n  eq-prefix: la ecuación\nformat:\n  html:\n    code-fold: true\n---\n\n::: {.cell}\n::: {.cell-output-display}\n![Adolphe Quetelet fue quien popularizó el uso del método de mínimos cuadrados en las ciencias sociales. Fuente: *Miscellaneous Items in High Demand, PPOC, Library of Congress, Public domain, via Wikimedia Commons*.](quetelet.jpg){fig-alt='Litografía de Aldophe Quetelet.' width=30%}\n:::\n:::\n\n\n## Paquetes y datos a utilizar en R\n\nA lo largo de esta sección usaremos los siguientes paquetes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(ggfortify)  #autoplot para diagnósticos\nlibrary(rstanarm)   #para regresión bayesiana\n\n#Siempre que uses tidymodels\ntidymodels_prefer()\n```\n:::\n\n\nEn general usaremos la filosofía `tidymodels` para combinar los resultados con el `tidyverse`. Si quieres saber más de `tidymodels` te recomiendo checar [su libro](https://www.tmwr.org) o [su página web](https://www.tidymodels.org/learn/).\n\n\n### Embarazo adolescente y pobreza\n\nPara los datos usaremos la información de [*Utts y Heckard*](https://online.stat.psu.edu/stat462/sites/onlinecourses.science.psu.edu.stat462/files/data/poverty/index.txt) para determinar si hay una relación entre embarazo adolescente y pobreza.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Lectura desde sitio web\nurl <- \"https://online.stat.psu.edu/stat462/sites/onlinecourses.science.psu.edu.stat462/files/data/poverty/index.txt\"\nemb_pob <- read_delim(url)\n```\n:::\n\n\nLas variables `Brth15to17` y `Brth18to19` son las tasas brutas de natalidad por cada 1000 mujeres (en el año 2002) en adolescentes de 15 a 17 años y de 18 a 19 respectivamente. La variable `PovPct` representa la proporción (%) de la población que vive bajo la línea de pobreza en cada una de las entidades de EEUU (`Location`). Las variables `ViolCrime` y `TeenBrth` no se explican por lo que no las usaremos.\n\n# Regresiones lineales\n\nUsaremos `Brth15to17` y `PovPct` para estudiar si hay una relación entre la tasa de natalidad en adolescentes y el porcentaje de la población en pobreza. Para ello comenzaremos con graficar:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(emb_pob) +\n  geom_point(aes(x = PovPct, y = Brth15to17), color = \"#bc5090\", size = 3) +\n  labs(\n    x = \"Porcentaje en pobreza\",\n    y = \"Tasa bruta de natalidad (por cada 1,000 mujeres adolescentes)\",\n    title = \"Relación entre tasa bruta de natalidad en adolescentes\\nde 15 a 19 años y porcentaje en pobreza\"\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nParece que a mayor porcentaje de pobreza, mayor tasa bruta de natalidad en adolescentes.\n\n## Planteamiento clásico\n\nSi la relación fuera perfecta todos los casos caerían *exactamente* en una línea recta como sigue:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\ndonde es necesario especificar dos parámetros: el intercepto (el valor que toma cuando la $x$ en este caso `PovPct` vale cero) y la pendiente (el valor que relaciona por cada unidad de aumento en `PovPct` cuánto aumenta `Brth15to17`).\n\nLa ecuación de la línea está dada por:\n\n$$\ny = \\beta_0 + \\beta_1 x\n$$\n\ndonde $\\beta_0$ es el intercepto y $\\beta_1$ la pendiente. Usando la terminología de arriba:\n\n$$\n\\text{Brth15to17} = \\text{Intercepto} + \\text{Pendiente}\\times \\text{PovPct}\n$$ en particular en ese ejemplo:\n\n$$\n\\text{Brth15to17} = 5 + 3\\cdot \\text{PovPct}\n$$\n\nLa idea es que el intercepto ($\\beta_0$ ó $5$) te indica dónde comienza tu línea cuando no tienes $x$'s (es decir cuando $\\text{PovPct} = 0$). El intercepto controla la altura de la línea como puedes ver en la siguiente gráfica donde puse varios interceptos distintos:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\npor otro lado la idea de la pendiente ($\\beta_1$ ó $3$) es retratar cómo cambia la $y$ (en este caso $\\text{Brth15to17}$) por cada unidad que cambia la $x$ (en este caso $\\text{PovPct}$). El valor de $3$ por ejemplo indica que por cada aumento en 1 en $\\text{PovPct}$ la variable $\\text{Brth15to17}$ aumenta en $3$. Este cambio es proporcional; es decir si ahora $\\text{PovPct}$ aumenta 4 (por decir algo) $\\text{Brth15to17}$ aumenta $3\\times 4 = 12$ unidades. La siguiente gráfica muestra varias líneas todas comenzando en el mismo intercepto de $5$:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nComo ya vimos en la primer figura el mundo no es tan perfecto que todo sea una línea recta. Hay un poco de aleatoriedad involucrada (sea por variables no medidas, por errores de medición o porque el mundo no sea determinista). Por lo cual se plantea que en lugar de que la $y$ sea *exactamente* $\\beta_0 + \\beta_1 x$ planteamos que la $y$ proviene de una variable aleatoria normal donde la media de esa normal **es** $\\beta_0 + \\beta_1 x$; es decir:\n\n$$\ny \\sim \\textrm{Normal}( \\beta_0 + \\beta_1 x, \\sigma^2)\n$$\n\no dicho de otra manera:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Normal}(\\text{Intercepto} + \\text{Pendiente}\\times \\text{PovPct}, \\sigma^2)\n$$\n\ndonde la $\\sigma^2$ es la varianza de dicha normal. Puesto gráficamente lo que esto quiere decir es que si, por ejemplo, el intercepto es $5$ y la pendiente $3$ entonces cada medición de $y$ viene de una normal ligeramente distinta:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Normal}(5 + 3\\times \\text{PovPct}, \\sigma^2)\n$$\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nDicho de otra forma, suponemos que en un mundo perfecto los valores de $y$ (`Brth15to17`) estarían completamente determinados por los de $x$ (`PovPct`) mediante la ecuación de la recta. **Pero** como el mundo no es perfecto entonces la $y$ proviene de una normal con promedio dado por la recta. Los puntos (como puedes ver an la siguiente gráfica) se centran más en torno a los promedios de las normales sin embargo están colocados aleatoriamente pues corresponden a distintas realizaciones de $y$.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nPor ejemplo si el porcentaje de pobreza (`PovPct`) es $10$ entonces la normal de la que provienen estos datos es:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Normal}(\\underbrace{5 + 3\\times 10}_{35}, \\sigma^2)\n$$\n\nmientras que si el porcentaje en pobreza es $20$ entonces la normal es:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Normal}(\\underbrace{5 + 3\\times 20}_{65}, \\sigma^2)\n$$\n\nPor supuesto que no hay nada de especial con el modelo normal y alguien podría elegir otra distribución (por ejemplo una Gamma) y establecer que:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Gamma}(\\text{Intercepto} + \\text{Pendiente}\\times \\text{PovPct}, \\beta)\n$$\n\nEstos modelos son algunos de los lineales generalizados y los discutiremos más adelante. Por ahora nos quedaremos con la idea del modelo dado por:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Normal}(\\text{Intercepto} + \\text{Pendiente}\\times \\text{PovPct}, \\sigma^2)\n$$\n\n> **Nota** quizá conoces la regresión lineal bajo la idea clásica de que $$\n> y = \\beta_0 + \\beta_1 x + \\epsilon\n> $$ donde $\\epsilon\\sim\\text{Normal}(0,\\sigma^2)$ son los errores normales. Esta definición es equivalente a la que damos aquí pues por [propiedades aditivas de la normal](https://en.wikipedia.org/wiki/Normal_distribution#Properties) $\\epsilon + \\beta_0 + \\beta_1 x$ se sigue distribuyendo normal pero con la media ahora dada por lo agregado ($\\beta_0 + \\beta_1 x$). Las ventajas de esta notación es que un modelo para regresión Poisson es simplemente: $$\n> y \\sim \\textrm{Poisson}\\big(\\exp(\\beta_0 + \\beta_1 x)\\big)\n> $$ y un modelo para regresión logística es: $$\n> y \\sim \\textrm{Bernoulli}\\big(\\textrm{logit}(\\beta_0 + \\beta_1 x)\\big)\n> $$\n\n## Planteamiento en `R`\n\nLo que nos toca ahora es programar nuestro modelo para ello seguiremos la filosofía de tidymodels que pretende unificar bajo la misma notación todos los modelos. La notación básica es como sigue:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodelo %>%\n  set_engine(\"tipo de ajuste\") %>%\n  fit(\"formula a ajustar\", data = tus_datos)\n```\n:::\n\n\nA partir del ajuste se pueden predecir cosas con `predict`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodelo %>%\n  set_engine(\"tipo de ajuste\") %>%\n  fit(\"formula a ajustar\", data = tus_datos) %>%\n  predict()\n```\n:::\n\n\no extraer nuevos datos con `extract_fit_engine` y `tidy`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodelo %>%\n  set_engine(\"tipo de ajuste\") %>%\n  fit(\"formula a ajustar\", data = tus_datos) %>%\n  extract_fit_engine() %>%\n  tidy()\n```\n:::\n\n\nComencemos con nuestro primer modelo: una regresión lineal clásica dada por:\n\n$$\n\\text{Brth15to17}  \\sim \\textrm{Normal}(\\text{Intercepto} + \\text{Pendiente}\\times \\text{PovPct}, \\sigma^2)\n$$\n\nEn `R` el `engine` que necesitamos es \"lm\" que es el clásico:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Ajusta un modelo lineal \n#Brth15to17 = intercepto + pendiente*PovPct\nmodelo_ajustado <- linear_reg() %>% \n  set_engine(\"lm\") %>%\n  fit(Brth15to17 ~ PovPct, data = emb_pob) #Notación y ~ x\n```\n:::\n\n\nNota que a diferencia de `Stata`, `R` no arroja demasiados resultados. Podemos usar `extract_fit_engine` combinado con `summary` para obtenerlos:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Ajusta un modelo lineal \n#Brth15to17 = intercepto + pendiente*PovPct\nmodelo_ajustado %>%\n  extract_fit_engine() %>%\n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nstats::lm(formula = Brth15to17 ~ PovPct, data = data)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.2275  -3.6554  -0.0407   2.4972  10.5152 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   4.2673     2.5297   1.687    0.098 .  \nPovPct        1.3733     0.1835   7.483 1.19e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.551 on 49 degrees of freedom\nMultiple R-squared:  0.5333,\tAdjusted R-squared:  0.5238 \nF-statistic:    56 on 1 and 49 DF,  p-value: 1.188e-09\n```\n:::\n:::\n\n\no bien con `tidy` si deseamos nos devuelva una tabla de resultados:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Ajusta un modelo lineal \n#Brth15to17 = intercepto + pendiente*PovPct\nmodelo_ajustado %>%\n  extract_fit_engine() %>%\n  tidy() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic       p.value\n  <chr>          <dbl>     <dbl>     <dbl>         <dbl>\n1 (Intercept)     4.27     2.53       1.69 0.0980       \n2 PovPct          1.37     0.184      7.48 0.00000000119\n```\n:::\n:::\n\n\nSegún el tipo de regresión que estemos haciendo es el tipo de tabla que regresa `tidy` (ver `?tidy`). En particular, por ejemplo, podemos modificar para que devuelva intervalos de confianza al 90%:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Ajusta un modelo lineal \n#Brth15to17 = intercepto + pendiente*PovPct\nmodelo_ajustado %>%\n  tidy(conf.int = T, conf.level = 0.90)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 7\n  term        estimate std.error statistic       p.value conf.low conf.high\n  <chr>          <dbl>     <dbl>     <dbl>         <dbl>    <dbl>     <dbl>\n1 (Intercept)     4.27     2.53       1.69 0.0980          0.0260      8.51\n2 PovPct          1.37     0.184      7.48 0.00000000119   1.07        1.68\n```\n:::\n:::\n\n\nEn este caso, el modelo estima que el intercepto ($\\beta_0$) es $4.27$ y la pendiente ($\\beta_1$) es $1.37$. Como son *estimadores* del verdadero valor se denotan con *gorrito*: $\\hat\\beta_0 = 4.27$ y $\\hat\\beta_1 = 1.37$.\n\nPodemos utilizar la función de `predict` para que el modelo nos muestre cómo cree que son los verdaderos valores en relación a los ajustados:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Ajusta un modelo lineal \n#Brth15to17 = intercepto + pendiente*PovPct\npredichos <- modelo_ajustado %>%\n  predict(new_data = emb_pob)\n\nintervalo_predichos <- modelo_ajustado %>%\n  predict(new_data = emb_pob, type = \"pred_int\", level = 0.95)\n\n#Juntamos los predichos con los observados\nobs_y_modelo <- emb_pob %>% \n  cbind(predichos) %>%\n  cbind(intervalo_predichos)\n\n#Graficamos\nggplot(obs_y_modelo) +\n  geom_ribbon(aes(x = PovPct, ymin = .pred_lower, ymax = .pred_upper), \n              fill = \"#003f5c\", size = 1, alpha = 0.5) +\n  geom_point(aes(x = PovPct, y = Brth15to17), color = \"#bc5090\", size = 3) +\n  geom_line(aes(x = PovPct, y = .pred), \n            color = \"#003f5c\", size = 1) +\n  labs(\n    x = \"Porcentaje en pobreza\",\n    y = \"Tasa bruta de natalidad (por cada 1,000 mujeres adolescentes)\",\n    title = \"Relación entre tasa bruta de natalidad en adolescentes\\nde 15 a 19 años y porcentaje en pobreza\"\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nNada más a ojo no parece que el modelo sea el mejor pues puedes ver que no explica bien la variabilidad (los observados varían mucho respecto al intervalo). La $R^2$, una métrica que explica cuánto de la varianza captura el modelo tampoco es muy buena:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nresumen_ajuste <- modelo_ajustado %>%\n  extract_fit_engine() %>%\n  summary()\n\n#R^2 clásica\nresumen_ajuste$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.533328\n```\n:::\n\n```{.r .cell-code  code-fold=\"false\"}\n#R^2 ajustada\nresumen_ajuste$adj.r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.523804\n```\n:::\n:::\n\n\nPodemos checar las diferentes gráficas de diagnóstico:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(ggfortify)\nautoplot(modelo_ajustado, which = 1:5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nVeamos qué significa cada una de ellas y juguemos un poco con `R` para irlas modificando.\n\n### Residuales contra ajustados\n\nLos **residuales** son la diferencia entre el modelo ($\\hat{y}$) y lo real $y$. En el caso que estábamos trabajando tenemos que con nuestro modelo podemos predecir los valores de `Brth15to17` a partir del porcentaje en pobreza `PovPct`. A los valores predichos por el modelo de `Brth15to17` les ponemos un gorro encima y los llamamos: $\\widehat{\\text{Brth15to17}}$. Estos están dados por la siguiente función:\n\n$$\n\\widehat{\\text{Brth15to17}} = 4.26 + 1.37 \\cdot \\text{PovPct}\n$$\n\npor ejemplo para el porcentaje en pobreza de $20.1$ obtendríamos:\n\n$$\n\\widehat{\\text{Brth15to17}} = 4.26 + 1.37 \\cdot \\text{PovPct} = 31.797\n$$\n\npor otro lado el verdadero valor de cuando el `PovPct` es $20.1$ (estado de `Alabama`) es $\\text{Brth15to17} = 31.5$. La diferencia entre el verdadero valor ($\\text{Brth15to17} = 31.5$) y el predicho por el modelo ($\\widehat{\\text{Brth15to17}} = 31.797$) se conoce como el residual. La idea es que en un modelo bueno no debe haber patrones en los residuales (todos deben de flotar en torno al cero pero no mostrar un patrón).\n\nVeamoslo en nuestra base:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobs_y_modelo <- obs_y_modelo %>%\n  mutate(residuales = Brth15to17 - .pred)\n\nggplot(obs_y_modelo) +\n  geom_point(aes(x = .pred, y = residuales), color = \"#ff6361\") +\n  labs(\n    x = \"Valores ajustados (predichos)\",\n    y = \"Residuales\",\n    title = \"Residuales vs ajustados\"\n  ) +\n  theme_bw() +\n  geom_hline(aes(yintercept = 0), linetype = \"dashed\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nEn esta gráfica el modelo predice mejor rumbo al final que en medio y esto parece estar corroborado por la gráfica del modelo (previa). Nada más para darnos una idea veamos una gráfica de *malos* residuales y una de *buenos*\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n### Escala locación\n\nRepresenta la escala locación contra los residuales estandarizados. La idea de la gráfica es ver que la varianza $\\sigma^2$ del modelo no cambie conforme cambia la $x$ (propiedad de *homoscedasticidad*). Para ello graficamos los residuales estandarizados dados por los residuales mismos dividos entre su desviación estándar:\n\n$$\nr_{\\text{Std}} = \\frac{\\hat{y} - y}{\\text{sd}(\\hat{y} - y)} = \\frac{\\text{Residuales}}{\\text{sd}\\big(\\text{Residuales}\\big)}\n$$\n\nestos residuales estandarizados los podemos calcular en `R` como sigue:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nobs_y_modelo <- obs_y_modelo %>%\n  mutate(residuales_std = residuales/sd(residuales))\n```\n:::\n\n\nSi los graficamos contra los valores ajustados no deberíamos de ver ningún patrón:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(obs_y_modelo) +\n  geom_point(aes(x = .pred, y = residuales_std), color = \"#ff6361\") +\n  labs(\n    x = \"Valores ajustados (predichos)\",\n    y = \"Residuales estandarizados\",\n    title = \"Escala Locación\"\n  ) +\n  theme_bw() +\n  geom_hline(aes(yintercept = 0), linetype = \"dashed\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nPodemos ver cómo se ven estos puntos en el modelo ideal vs en un modelo donde la $\\sigma^2$ depende de la $x$:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n### Normal cuantil cuantil\n\nLa segunda gráfica corresponde a una gráfica cuantil cuantil. Esta la utilizamos para verificar la hipótesis de normalidad. En una gráfica cuantil cuantil se grafican los cuantiles de los residuales contra los cuantiles teóricos de la normal. Por ejemplo si la hacemos con sólo 4 puntos se vería algo así:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nPodemos armar una gráfica cuantil cuantil con `ggplot2`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nggplot(obs_y_modelo, aes(sample = residuales)) + \n  stat_qq(color = \"#ff6361\") + \n  stat_qq_line(color = \"#58508d\") +\n  theme_bw() +\n  labs(\n    x = \"Cuantiles teóricos de la normal\",\n    y = \"Cuantiles observados de los residuales\",\n    title = \"Gráfica qq\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nLa idea de la gráfica cuantil cuantil es que los puntos sigan la línea lo más posible. Veamos cómo se ve con los datos bien (y los mal)\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### Residuales contra apalancamiento\n\nEl apalancamiento representa qué tanto cambia el modelo al quitar una sola observación. Para poner un ejemplo considera los siguientes datos donde hay un valor atípico y selecciono dos puntos de interés en dos colores:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nVeamos cómo cambia la regresión si dejo todos los puntos, si quito el normal y si quito el influyente:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\nNota que el modelo no cambia prácticamente nada cuando hago la regresión sin el dato que marqué como `normal` pero cambia mucho cuando quito el que marqué como `influyente`. La gráfica de residuales contra apalancamiento muestra también el valor extraño:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nEl apalancamiento mide la influencia de un dato y en `R` se puede calcular con `hatvalues`. Los datos con mayor **apalancamiento** siempre valen la pena checarlos para verificar que todo opera en orden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napalancamiento <- modelo_ajustado %>%\n  extract_fit_engine() %>%\n  hatvalues()\n\nobs_y_modelo <- obs_y_modelo %>%\n  cbind(apalancamiento)\n\n#Graficamos residuales contra apalancamiento\nggplot(obs_y_modelo) +\n  geom_point(aes(x = apalancamiento, y = residuales), color = \"#ff6361\") +\n  labs(\n    x = \"Apalancamiento\",\n    y = \"Residuales\",\n    title = \"Residuales vs ajustados\"\n  ) +\n  theme_bw() +\n  geom_hline(aes(yintercept = 0), linetype = \"dashed\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n### Distancia de Cook\n\nLa distancia de Cook es un concepto similar al apalancamiento que identifica observaciones influyentes. Aquellos valores con distancia de Cook alta vale la pena revisar. En `R` podemos usar `cooks.distance` para calcular la distancia de Cook.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistanciaCook <- modelo_ajustado %>%\n  extract_fit_engine() %>%\n  cooks.distance()\n\nobs_y_modelo <- obs_y_modelo %>%\n  cbind(distanciaCook)\n\n#Graficamos residuales contra apalancamiento\nggplot(obs_y_modelo) +\n  geom_col(aes(x = 1:nrow(obs_y_modelo), y = distanciaCook), fill = \"#ff6361\") +\n  labs(\n    x = \"Observación (número de entrada en la base)\",\n    y = \"Distancia de Cook\",\n    title = \"Distancia de Cook\"\n  ) +\n  theme_bw() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\npodemos ver que en el ejemplo anterior (el de la observación influyente) la distancia de Cook es exagerada, tan exagerada que ni se alcanzan a ver los otros:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n## Ejercicios\n\n1.  Corre el siguiente código para generar una base de datos de nombre `datLong` que contiene $4$ grupos. Para cada grupo genere una regresión lineal de la forma:\n\n$$\ny = \\beta_0 + \\beta_1 x\n$$\n\nIdentifica cuáles regresiones sí ajustan bien y cuáles no mediante los gráficos de diagnóstico. Finalmente grafica tus datos $x$ contra $y$ y la regresión para ver que lo hayas hecho bien. ¿Hay alguna forma de corregir alguna de las que no ajusta bien?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ndat <- datasets::anscombe\ndatLong <- data.frame(\n    grupo  = rep(1:4, each = 11),\n    x = unlist(dat[,c(1:4)]),\n    y = unlist(dat[,c(5:8)])\n    )\nrownames(datLong) <- NULL\n```\n:::\n\n\n2.  Lee la base de datos de $n = 345$ niños entre $6$ y $10$ años de [Kahn, Michael (2005)](https://online.stat.psu.edu/stat462/sites/onlinecourses.science.psu.edu.stat462/files/data/fev_dat/index.txt). Las variables de interés son $y = \\text{FEV}$ el volumen de expiración forzada y $x = \\text{edad}$ en años. Realiza una regresión lineal. Justifica que no se cumple la homocedasticidad mediante una gráfica de escala locación.\n\n3.  Plantee una regresión lineal usando [los datos de esta liga](https://data.princeton.edu/wws509/datasets/#salary) para determinar si el sexo influye en el salario. **Ojo** en la regresión es necesario incluir otras covariables.\n\n## ¿Y si lo hacemos bayesiano?\n\nPara hacer la misma regresión lineal pero con estadística bayesiana podemos nada más cambiar el `engine`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n#Ajusta un modelo lineal \n#Brth15to17 = intercepto + pendiente*PovPct\nmodelo_bayesiano <- linear_reg() %>% \n  set_engine(\"stan\") %>%\n  fit(Brth15to17 ~ PovPct, data = emb_pob) #Notación y ~ x\n```\n:::\n\n\nY podemos ver el ajuste:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodelo_bayesiano %>%\n  extract_fit_engine() %>%\n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nModel Info:\n function:     stan_glm\n family:       gaussian [identity]\n formula:      Brth15to17 ~ PovPct\n algorithm:    sampling\n sample:       4000 (posterior sample size)\n priors:       see help('prior_summary')\n observations: 51\n predictors:   2\n\nEstimates:\n              mean   sd   10%   50%   90%\n(Intercept) 4.3    2.6  0.9   4.3   7.7  \nPovPct      1.4    0.2  1.1   1.4   1.6  \nsigma       5.7    0.6  4.9   5.6   6.4  \n\nFit Diagnostics:\n           mean   sd   10%   50%   90%\nmean_PPD 22.3    1.1 20.9  22.3  23.7 \n\nThe mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help('summary.stanreg')).\n\nMCMC diagnostics\n              mcse Rhat n_eff\n(Intercept)   0.0  1.0  4252 \nPovPct        0.0  1.0  4286 \nsigma         0.0  1.0  3968 \nmean_PPD      0.0  1.0  4057 \nlog-posterior 0.0  1.0  1705 \n\nFor each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).\n```\n:::\n:::\n\n\no realizar predicciones:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npredichos <- modelo_bayesiano %>%\n  extract_fit_engine() %>%\n  predict(new_data = emb_pob)\n\nic <- modelo_bayesiano %>%\n  extract_fit_engine() %>%\n  predictive_interval(newdata = emb_pob, prob = 0.95) #Para bayesiana\n\n#Juntamos los predichos con los observados\nobs_y_modelo <- emb_pob %>% \n  cbind(predichos) %>%\n  cbind(ic)\n\n#Graficamos\nggplot(obs_y_modelo) +\n  geom_ribbon(aes(x = PovPct, ymin = `2.5%`, ymax = `97.5%`), \n              fill = \"#003f5c\", size = 1, alpha = 0.5) +\n  geom_point(aes(x = PovPct, y = Brth15to17), color = \"#ffa600\", size = 3) +\n  geom_line(aes(x = PovPct, y = predichos), \n            color = \"#003f5c\", size = 1) +\n  labs(\n    x = \"Porcentaje en pobreza\",\n    y = \"Tasa bruta de natalidad (por cada 1,000 mujeres adolescentes)\",\n    title = \"Relación entre tasa bruta de natalidad en adolescentes\\nde 15 a 19 años y porcentaje en pobreza\"\n  ) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\nPara validación del modelo puedes checar [esta página](https://mc-stan.org/rstanarm/articles/rstanarm.html#step-3-criticize-the-model-1) que explica `loo` ([ver paper](https://arxiv.org/abs/1507.04544):\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodelo_bayesiano %>%\n  extract_fit_engine() %>% \n  loo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nComputed from 4000 by 51 log-likelihood matrix\n\n         Estimate  SE\nelpd_loo   -161.6 4.2\np_loo         2.4 0.5\nlooic       323.3 8.4\n------\nMonte Carlo SE of elpd_loo is 0.0.\n\nAll Pareto k estimates are good (k < 0.5).\nSee help('pareto-k-diagnostic') for details.\n```\n:::\n:::\n\n\nasi como su visualización (si el modelo no fuera bueno)\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nmodelo_bayesiano %>%\n  extract_fit_engine() %>% \n  loo() %>%\n  plot(label_points = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n## Ejercicio\n\n1.  Utilice las opciones de `engine` para cambiar el `prior_intercept` del intercepto a una `t` de Student y el `prior` de los coeficientes a una `Laplace`. ¿Cambia mucho el resultado?\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}